### http 和 https 相关知识点总结

##### 网络模型

* 7 层网络模型

![7层网络模型](http://img.blog.csdn.net/20160127132708631?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

1》应用层：提供给操作系统或者应用程序，用来进行网络通信的标准接口

2》表示层：不同的 pc 机拥有不同的编码方式，需要在这里进行转换，转换成网络通信中采用的标准表现形式

3》会话层：负责在不同的 PC 的不同进程之间建立或者拆除连接，另外，还有插入同步点的机制（保证断线重新从这个位置传输）

4》传输层：负责两个主机之间的端对端的数据连接&传输

5》网络层：选择合适的路由，职责就是正确的找着目的站

6》数据链路层：负责在两个相邻的节点之间准确的传输数据（以帧为单位，每一帧：数据+控制信息）

7》物理层：让原始的数据比特流能在物理介质上传输

* 4 层网络模型

![4层网络模型](http://img.blog.csdn.net/20160127132929760?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

1》应用层：向网络应用提供接口，并且对应用内的数据格式进行统一编码

2》传输层：负责两个主机之间的端对端的数据连接&传输&传输控制、错误恢复

3》网络层：选择合适的路由，职责就是正确的找着目的站

4》网络接口层：负责通过网络发送和接收 IP 数据报

##### DNS 查询过程

* 查找浏览器缓存
* 查找系统缓存
* 查找路由器缓存
* 查找 ISP DNS 缓存
* 递归从根域开始搜索

**耗时**

```js
let pt = window.performance.timeing
let dns = pt.domainLookupEnd - pt.domainLookuoStart
```

**优化建议**

* 控制域名数量，推荐是两个。
* 使用缓存 Last-Modified，If-Modified-Since，ETag，If-None-Match，Expires，Cache-Control。
* 使用 CDN，提高缓存命中率。
* 服务根据需要设置合理的 TTL。
* DNS 的预解析。

##### 缓存协商

**Last-Modified 与 If-Modified-Since**

* 浏览器第一次请求资源时，服务器会把资源的最新修改时间 Last-Modified:Thu, 29 Dec 2011 18:23:55 GMT 放在响应头中返回给浏览器
* 第二次请求时，浏览器就会把上一次服务器返回的修改时间放在请求头 If-Modified-Since:Thu, 29 Dec 2011 18:23:55 发送给服务器，服务器就会拿这个时间跟服务器上的资源的最新修改时间进行对比

如果两者相等或者大于服务器上的最新修改时间，那么表示浏览器的缓存是有效的，此时缓存会命中，服务器就不再返回内容给浏览器了，同时 Last-Modified 头也不会返回，因为资源没被修改，返回了也没什么意义。如果没命中缓存则最新修改的资源连同 Last-Modified 头一起返回。

**ETag 与 If-None-Match**

ETag/If-None-Match 与 Last-Modified/If-Modified-Since 的流程其实是类似的，唯一的区别是它基于资源的内容的摘要信息（比如 MD5 hash）来判断

浏览器发送第二次请求时，会把第一次的响应头信息 ETag 的值放在 If-None-Match 的请求头中发送到服务器，与最新的资源的摘要信息对比，如果相等，取浏览器缓存，否则内容有更新，最新的资源连同最新的摘要信息返回。用 ETag 的好处是如果因为某种原因到时资源的修改时间没改变，那么用 ETag 就能区分资源是不是有被更新。

##### 加密算法相关

> 1、对称加密

有流式、分组两种，加密和解密都是使用的同一个密钥。

例如：DES、AES-GCM、ChaCha20-Poly1305 等，最常用的就是 DES

> 2、非对称加密

加密使用的密钥和解密使用的密钥是不相同的，分别称为：公钥、私钥，公钥和算法都是公开的，私钥是保密的。非对称加密算法性能较低，但是安全性超强，由于其加密特性，非对称加密算法能加密的数据长度也是有限的。

例如：RSA、DSA、ECDSA、 DH、ECDHE,最常用的就是 RSA

> 3、哈希算法

将任意长度的信息转换为较短的固定长度的值，通常其长度要比信息小得多，且算法不可逆。

例如：MD5、SHA-1、SHA-2、SHA-256 等

> 4、数字签名

签名就是在信息的后面再加上一段内容（信息经过 hash 后的值），可以证明信息没有被修改过。hash 值一般都会加密后（也就是签名）再和信息一起发送，以保证这个 hash 值不被修改。

##### http 详情

> 1、http 访问过程

主要就是三次握手的过程。
![三次握手](http://pic4.zhimg.com/v2-e367a5e3bc28fb7fd083ddc201e7e693_b.png)
从上图可以看出客户端和服务端之间的数据传输都是“裸奔”的

![中间人](http://pic4.zhimg.com/v2-831635f04f3732e866af0ec6ce1040e7_b.png)
从上图可以看出，http 请求在发送过程中，客户端与服务端之间没有任何身份确认的步骤，数据全部是裸奔在网络上。有人存心想攻击你的话，直接在客户端和服务端之间截获消息的传递。消息截获后，黑客就可以冒充服务端给客户端返回消息了。这一现象也是我们常说的劫持。

所以 http 传输所面临的风险就是：

* 窃听风险：黑客可以获取通信内容
* 篡改风险：黑客可以修改通信内容
* 冒充风险：黑客可以冒充他人的身份参与通信

##### http 向 https 演化的过程

> 1、传输内容对称加密

因为信息泄露大概率是因为信息的明文传输，所以想到这点，于是就产生了加密传输内容的方法。（黑客在不知道密钥的情况下是不能解密来知道传输内容的）
![传输内容对称加密](http://pic1.zhimg.com/v2-8d8138e883455e4d316d644c79a89314_b.png)

这种方式还是有很多缺点的：

* 不同客户端和服务端众多，那么就要维护很多的密钥，导致维护成本会很高
* 因为每个客户端和服务端的安全级别不一样，所以也会导致密钥的泄露

> 2、传输内容非对称加密

因为传输内容对称加密的缺点，那么我们就可以换种思路了。就将传输内容非对称加密后传输。
![传输内容非对称加密](http://pic2.zhimg.com/v2-660bec42419281a9ec47c029089a77c9_b.png)

如上图所示，客户端用公钥对请求内容加密，服务器使用私钥对内容解密，反之亦然，但上述过程也存在缺点：

* 公钥是公开的（也就是黑客也会有公钥），所以第 ④ 步私钥加密的信息，如果被黑客截获，其可以使用公钥进行解密，获取其中的内容

> 3、对称加密和非对称加密的结合

通过上面的两步，我们发现两种方式都有着自己的优缺点。那么我们就将这两种方式结合起来。取其精华，去其糟粕，发挥各自的优点就好了。

![两种方式结合](http://pic3.zhimg.com/v2-22570e3e422de7951ce7c5c3e8435312_b.png)

* 如上图所示第 ③ 步时，客户端说：（咱们后续回话采用对称加密吧，这是对称加密的算法和对称密钥）这段话用公钥进行加密，然后传给服务器
* 服务器收到信息后，用私钥解密，提取出对称加密算法和对称密钥后，服务器说：（好的）对称密钥加密
* 后续两者之间信息的传输就可以使用对称加密的方式了

上面还是会有问题的：

* 第一步中的公钥怎么获取
* 怎么确信当前送到服务器是真实的服务器而不是黑客呢？

> 4、获取公钥和身份确认

![获取公钥和身份确认](http://pic3.zhimg.com/v2-f2ac6567fa1a3c10e73eba59eab3823a_b.png)

**获取公钥**

* 提供一个下载公钥的地址，回话前让客户端去下载。（缺点：下载地址有可能是假的；客户端每次在回话前都先去下载公钥也很麻烦）
* 回话开始时，服务器把公钥发给客户端（缺点：黑客冒充服务器，发送给客户端假的公钥）

那有木有一种方式既可以安全的获取公钥，又能防止黑客冒充呢？ 那就需要用到终极武器了：SSL 证书

![带证书](http://pic1.zhimg.com/v2-5e2241fae8b593ff7f3b3a308ef81c10_b.png)

**SSL 证书包括：**

* 证书颁发机构的 CA
* 证书的有效期
* 公钥
* 证书所有者
* 签名
* 等等

> 5、SSL 证书校验

* 首先浏览器读取证书中的证书所有者、有效期等信息进行一一校验
* 浏览器开始查找操作系统中已内置的受信任的证书发布机构 CA，与服务器发来的证书中的颁发者 CA 比对，用于校验证书是否为合法机构颁发
* 如果找不到，浏览器就会报错，说明服务器发来的证书是不可信任的。
* 如果找到，那么浏览器就会从操作系统中取出 颁发者 CA 的公钥，然后对服务器发来的证书里面的签名进行解密
* 浏览器使用相同的 hash 算法计算出服务器发来的证书的 hash 值，将这个计算的 hash 值与证书中签名做对比
* 对比结果一致，则证明服务器发来的证书合法，没有被冒充
* 此时浏览器就可以读取证书中的公钥，用于后续加密了
