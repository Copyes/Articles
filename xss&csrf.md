### 关于 XSS 攻击和 CSRF 攻击的总结

> 对于跨站脚本攻击（XSS 攻击）的理解和总结

**什么是 XSS 攻击**

* XSS 是跨站脚本攻击的缩写，是一种网站应用程序的安全漏洞攻击，是代码注入的一种。
* 通常是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。
* 这些恶意网页程序通常是 JavaScript，但实际上也可以包括 Java，VBScript，ActiveX，Flash 或者甚至是普通的 HTML。
* 攻击成功后，攻击者可能得到更高的权限（如执行一些操作）、私密网页内容、会话和 cookie 等各种内容。

**XSS 攻击基本原理---代码注入**

在 web 的世界里有各种各样的语言，于是乎对于语句的解析大家各不相同，有一些语句在一种语言里是合法的，但是在另外一种语言里是非法的。这种二义性使得黑客可以用代码注入的方式进行攻击——将恶意代码注入合法代码里隐藏起来，再诱发恶意代码，从而进行各种各样的非法活动。只要破坏跨层协议的数据/指令的构造，我们就能攻击。历史悠久的 SQL 注入和 XSS 注入都是这种攻击方式的典范。现如今，随着参数化查询的普及，我们已经离 SQL 注入很远了。但是，历史同样悠久的 XSS 却没有远离我们。
XSS 的基本实现思路很简单——比如持久型 XSS 通过一些正常的站内交互途径，例如发布评论，提交含有 JavaScript 的内容文本。这时服务器端如果没有过滤或转义掉这些脚本，作为内容发布到了页面上，其他用户访问这个页面的时候就会运行这些脚本，从而被攻击。

**攻击分类**

* 反射型 XSS

反射性 XSS，也就是被动的非持久性 XSS。诱骗用户点击 URL 带攻击代码的链接，服务器解析后响应，在返回的响应内容中隐藏和嵌入攻击者的 XSS 代码，被浏览器执行，从而攻击用户。
URL 可能被用户怀疑，但是可以通过短网址服务将之缩短，从而隐藏自己。

* 持久型 XSS

也叫存储型 XSS——主动提交恶意数据到服务器，攻击者在数据中嵌入代码，这样当其他用户请求后，服务器从数据库中查询数据并发给用户，用户浏览此类页面时就可能受到攻击。可以描述为:恶意用户的 HTML 或 JS 输入服务器->进入数据库->服务器响应时查询数据库->用户浏览器。

**防范**

* 使用 XSS Filter

输入过滤，对用户提交的数据进行有效性验证，仅接受指定长度范围内并符合我们期望格式的的内容提交，阻止或者忽略除此外的其他任何数据。

输出转义，当需要将一个字符串输出到 Web 网页时，同时又不确定这个字符串中是否包括 XSS 特殊字符，为了确保输出内容的完整性和正确性，输出 HTML 属性时可以使用 HTML 转义编码（HTMLEncode）进行处理，输出到<script>中，可以进行 JS 编码。

* 使用 HttpOnly Cookie

将重要的 cookie 标记为 httponly，这样的话当浏览器向 Web 服务器发起请求的时就会带上 cookie 字段，但是在 js 脚本中却不能访问这个 cookie，这样就避免了 XSS 攻击利用 JavaScript 的 document.cookie 获取 cookie

> 对于跨站伪造请求（CSRF）的理解和总结

**什么是 CSRF 攻击**

CSRF 是跨站请求伪造的缩写，也被称为 XSRF， 是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。跟跨网站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。因为 CSRF 攻击利用的是冲着浏览器分不清发起请求是不是真正的用户本人。，也就是说，简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。

**XSS 攻击基本原理**

* 最简单的 csrf 攻击

用户 Alice 登录和访问某银行网站 A，保留 cookie。
Alice 被某些信息诱导访问危险网站 B。危险网站 B 上有一个`<img>`标签：`<img src="http://www.examplebank.com/account=Alice&amount=1000&payfor=Badman" >`
这个标签的 src 不指向一张图片，而是一个 http 请求，这个请求向银行要求将 Alice 的 1000 元转给 Badman，由于 Alice 的浏览器上有 cookie，这样浏览器发出的这个请求就能得到响应执行。这样 Alice 的钱就被偷了。

* 进阶攻击

危险网站可以伪造一个表单并隐藏，并在自己网站的 onload 事件中，触发这个表单的提交事件，就可以改 GET 攻击为 POST 攻击

**防范**

* 最基本的手段：涉及敏感操作的请求改为 POST 请求

这个方法的确可以防范一些 CSRF 攻击，但是对于进阶攻击就无能为力了——POST 请求一样可以伪造。

输出转义，当需要将一个字符串输出到 Web 网页时，同时又不确定这个字符串中是否包括 XSS 特殊字符，为了确保输出内容的完整性和正确性，输出 HTML 属性时可以使用 HTML 转义编码（HTMLEncode）进行处理，输出到<script>中，可以进行 JS 编码。

* 用户操作限制——验证码机制

方法：添加验证码来识别是不是用户主动去发起这个请求，由于一定强度的验证码机器无法识别，因此危险网站不能伪造一个完整的请求。优点：简单粗暴，低成本，可靠，能防范 99.99%的攻击者。缺点：对用户不友好。

* 请求来源限制——验证 HTTP Referer 字段

方法：在 HTTP 请求头中有一个字段叫 Referer，它记录了请求的来源地址。 服务器需要做的是验证这个来源地址是否合法，如果是来自一些不受信任的网站，则拒绝响应。

优点：零成本，简单易实现。

缺点：由于这个方法严重依赖浏览器自身，因此安全性全看浏览器。

兼容性不好：每个浏览器对于 Referer 的具体实现可能有差别。

并不一定可靠：在一些古老的垃圾浏览器中，Referer 可以被篡改。对用户不友好：Referer 值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权。因此有些用户可能会开启浏览器防止跟踪功能，不提供 Referer，从而导致正常用户请求被拒绝。

* 额外的验证机制--token 的使用

[token](http://www.imooc.com/article/13552)
